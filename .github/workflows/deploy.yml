name: Deploy to DigitalOcean Droplet

on:
  push:
    branches:
      - main # Or whichever branch triggers deployment

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to Droplet
        uses: appleboy/ssh-action@master 
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: 22 # Default SSH port
          script: |
            set -e # Exit immediately if a command exits with a non-zero status.
            cd /root/roster-royals
            echo "Pulling latest code from main branch..."
            git pull origin main
            echo "Stopping containers to allow volume removal..."
            docker compose -f docker-compose.yml -f docker-compose.prod.yml down
            echo "Removing stale react_build volume..."
            docker volume rm roster-royals_react_build || true # Remove volume, continue if it doesn't exist
            echo "Starting DB and Web services for migrations..."
            docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d pgdb django-web # Start DB and Web

            echo "Ensuring correct database ownership and permissions..."
            # Wait a brief moment for PostgreSQL to initialize fully
            sleep 5
            # Explicitly source the .env file to load DB credentials into the shell environment
            # Assuming .env is in the current directory (/root/roster-royals)
            if [ -f .env ]; then
              echo "Sourcing .env file..."
              set -a # Automatically export all variables defined in .env
              source .env
              set +a # Stop automatically exporting
            else
              echo "Warning: .env file not found in $(pwd). Relying on existing environment variables."
            fi
            # Debug: Print the variables to see if they were loaded correctly
            echo "Using POSTGRES_USER='${POSTGRES_USER:-'(unset)'}' POSTGRES_DB='${POSTGRES_DB:-'(unset)'}'"

            # Execute commands as the POSTGRES_USER inside the 'pgdb' container
            # Connect to the 'postgres' db for the ALTER DATABASE command
            docker compose -f docker-compose.yml -f docker-compose.prod.yml exec -T pgdb psql -U "${POSTGRES_USER:-postgres}" -d postgres -c "ALTER DATABASE \"${POSTGRES_DB:-postgres}\" OWNER TO \"${POSTGRES_USER:-postgres}\";" || echo "Continuing after potential harmless error changing DB owner..."
            # Connect to the specific application DB for GRANT commands
            docker compose -f docker-compose.yml -f docker-compose.prod.yml exec -T pgdb psql -U "${POSTGRES_USER:-postgres}" -d "${POSTGRES_DB:-postgres}" -c "GRANT ALL PRIVILEGES ON SCHEMA public TO \"${POSTGRES_USER:-postgres}\";" || echo "Continuing after potential harmless error granting schema privileges..."
            docker compose -f docker-compose.yml -f docker-compose.prod.yml exec -T pgdb psql -U "${POSTGRES_USER:-postgres}" -d "${POSTGRES_DB:-postgres}" -c "GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO \"${POSTGRES_USER:-postgres}\";" || echo "Continuing after potential harmless error granting table privileges..."
            docker compose -f docker-compose.yml -f docker-compose.prod.yml exec -T pgdb psql -U "${POSTGRES_USER:-postgres}" -d "${POSTGRES_DB:-postgres}" -c "GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO \"${POSTGRES_USER:-postgres}\";" || echo "Continuing after potential harmless error granting sequence privileges..."

            echo "Re-assigning ownership of all tables and sequences in ${POSTGRES_DB}…"
            # Run the ALTER OWNER loop as the real postgres superuser, in one go:
            docker compose -f docker-compose.yml -f docker-compose.prod.yml exec -T -u postgres pgdb \
              psql -d "${POSTGRES_DB}" -v ON_ERROR_STOP=1 \
              -c "DO \$\$ 
                DECLARE rec RECORD; 
                BEGIN 
                  -- Tables
                  FOR rec IN (SELECT schemaname, tablename FROM pg_tables WHERE schemaname = 'public') LOOP 
                    EXECUTE format('ALTER TABLE %I.%I OWNER TO %I;', rec.schemaname, rec.tablename, '${POSTGRES_USER}'); 
                  END LOOP; 
                  -- Sequences
                  FOR rec IN (SELECT sequence_schema, sequence_name FROM information_schema.sequences WHERE sequence_schema = 'public') LOOP 
                    EXECUTE format('ALTER SEQUENCE %I.%I OWNER TO %I;', rec.sequence_schema, rec.sequence_name, '${POSTGRES_USER}'); 
                  END LOOP; 
                END 
              \$\$;"

            echo "Running database migrations…"
            docker compose -f docker-compose.yml -f docker-compose.prod.yml exec django-web \
              python manage.py migrate
            echo "Cleaning up Docker build cache on runner..."
            # Build cache pruning on runner is less relevant now, but harmless to keep
            docker builder prune -af || true
            # REMOVE Build step from runner environment
            # echo "Rebuilding Docker images without cache..."
            # REACT_APP_API_URL="${{ secrets.REACT_APP_API_URL_SECRET }}" docker compose -f docker-compose.yml -f docker-compose.prod.yml build --no-cache

            # ADD Build step to run on the droplet itself
            echo "Rebuilding Docker images on the droplet..."
            # This build command uses the .env file present on the droplet
            docker compose -f docker-compose.yml -f docker-compose.prod.yml build --no-cache

            echo "Starting ALL Docker containers..."
            # Use 'up -d' which will use the images just built on the droplet
            docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d
            # Optional: Prune unused Docker images, containers, and volumes to save space
            # echo "Pruning Docker system..."
            # docker system prune -af
            echo "Deployment successful!" 